<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="content-security-policy" content=""><title>Kleidi Bujari</title><link rel="shortcut icon" href="/icon.png" type="image/x-icon" data-svelte="svelte-1arag7i">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/__layout.svelte-4917f737.css">
	<link rel="modulepreload" href="/_app/immutable/start-4a16ffde.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/index-59d3e747.js">
	<link rel="modulepreload" href="/_app/immutable/pages/__layout.svelte-7098c712.js">
	<link rel="modulepreload" href="/_app/immutable/pages/blog/windows-vm-passthrough.md-da2b7858.js">
  </head>
  <body>
    <div>




<main><div class="max-w-4xl mx-auto mt-12 p-4"><div class="flex justify-evenly items-center"><p>2022-01-15</p>
    <span>|</span>
    <a href="/blog" class="link"><p>Back to Posts</p></a>
    <span>|</span>
    <p>Length: Medium</p></div>
  <h1 class="my-8 text-4xl font-bold text-center">Making a High performance Win10 VM with GPU-Passthrough</h1>
  <div class="post-data"><p>In early 2021, I transitioned my personal computers to Arch Linux and while the experience has been excellent overall, there are a few shortcomings in the software compatibility department, mainly with a few games (League of Legends) and software I need to use for school (Multisim). While these can be “run” using wine, I found that the experience left a lot to be desired, and for school especially, I wanted to make sure I was in an environment supported by my classes.</p>
<br>
<p>This led to the decision to use Windows for these as well as anything else not supported well by linux. At this point you might be asking why I’m not just dual-booting for simplicity. The main reasons are that I’ve gotten annoyed with a lot of the telemetry, excess, and clunkiness of running Windows natively on my desktop as well as for the sake of getting some experience with QEMU/KVM on Linux. Note that this won’t be a full guide to the process, but more of a showcase on how I set it up for myself.</p>
<br>
<p>Feel free to use anything mentioned here for yourself and be sure to follow along with the files mentioned by viewing them yourself on my <a href="https://github.com/kleidibujari/virt-machine" rel="nofollow">github</a>. Without further rambling, let’s get into the important parts.</p>
<br>
<h2>Hardware &amp; Specifics</h2>
<br>
<p><strong>CPU:</strong> AMD Ryzen 7 3700x <br>
<strong>RAM:</strong> 16GB DDR4 3600MHz <br>
<strong>GPU:</strong> EVGA RTX 2080 XC Gaming <br></p>
<br>
<p>While most hardware choices don’t really matter for this kind of virtualization, eg. get as much memory as you can, have a processor with a lot of threads; one recommendation I can make is to not get an Nvidia GPU. Not only is this good advice for anyone looking to transition to a Linux desktop due to proprietary drivers and other headaches, but it plays a large part in the complexity of this setup as I painfully learned trying to figure out why the VM wouldn’t start when I first set it up, more on this later.</p>
<br>
<p>Other than that, my experience was pretty standard. Setting up a VM through virt-manager and libvirt was the same process as any other type of VM. I installed Windows normally using the default video drivers provided by QEMU and virtio drivers for disks, network, etc, before doing anything GPU related to make sure any errors I had to solve later weren’t related to the VM itself. </p>
<br>
<h2>GPU Passthrough</h2>
<br>
<div style="display: flex; justify-content: center;"><p><img src="/blog/windows-vm-passthrough/gpu-hex.png" alt="vbios hex dump"></p></div>
<p>Above is my edited vBios file that is passed through to the VM. Usually, when you load into a graphical session, the vBios gets changed as you use the GPU. Because of this, a new vBios is given to the VM to use. Next, to add the GPU alongside any other devices such as a USB controller, I had to get the relevant IOMMU groups. \ Here’s an example of what the GPU group looked like on my system: </p>
<br>
<p>These were added to the xml file containing all the information for the VM. </p>
<br>
<p>Now that the normal setup is done, we can move on to specifics in a single GPU setup. The idea is for this process is generally as follows: </p>
<br>
<ol><li>Stop the host display server</li>
<li>Unload all GPU drivers</li>
<li>Load the vfio kernel modules in their place</li></ol>
<br>
<p>This is accomplished with scripts that are triggered by the VM starting and stopping. Naturally, start.sh handles startup, with the IOMMU groups sourced from kvm.conf. Lucky for me, you only need to edit the vBios file on Nvidia GPUs. Most documention said this was only required for pascal series (eg. GTX 1070), however, I was unable to get the VM to properly boot without this step. Keep that in mind if you plan on having a similar setup. </p>
<br>
<h2>Optimization</h2>
<br>
<p>Now that I had a working VM, the next goal was to reduce any latency and overhead from virtualising Windows. Since I planned to play some competitive games that don’t run on linux, it was important to me to make it feel like I was playing on bare metal. The main things I used for this were CPU Pinning and HugePages <a href="https://wiki.archlinux.org/title/KVM#Enabling_huge_pages" rel="nofollow">(Arch Wiki)</a>. CPU pinning manually allocates certain threads to the VM so the host doesn’t use them as well, introducing latency. This is configured on a per-CPU basis since every processor has it’s own architechture. In my case, the Ryzen 7 3700x has the following layout: </p>
<br>
<div style="display: flex; justify-content: center;"><p><img src="/blog/windows-vm-passthrough/lstopo.png" alt="vbios hex dump"></p></div>
<br>
<p>The important sections to look at are the grey boxes which represent a physical core, and the group of grey boxes itself which represents a CCX (Core Complex). I chose to only include cores from one of the two CCX present on the CPU. Since the VM will only be used for gaming and schoolwork, 8 threads should be more than enough performance. Using only one CCX will also improve latency since the cores won’t have to wait on information from the other CCX. Lastly, I chose the second or bottom CCX since I want to leave Core #0 for the host. All of this can be seen in the xml file, specifically in the “cputune” section. </p>
<br>
<p>The last major optimization I included was HugePages. Without going into too much detail, it is an alternate way of providing memory to the VM, which results in a massive difference in performance according to my testing. It is manually allocated using the scripts triggered at startup and deallocated upon closing the VM. I stronly recommend looking into HugePages if you decide to use a setup like this. There were a few other small optimizations that I applied and you might be able to find in the xml file, but they didn’t provide enough of a difference to be meaningful in my opinion. </p>
<br>
<h2>Hyper-V</h2>
<br>
<p>Hyper-V is a virtualization platform on Windows, and it’s normally used in this case to hide the nature of the host to the guest machine. In other words, you can use it to hide the fact that you are using a VM to circumvent some anti-cheats and other software restrictions. I chose not to use it in my setup due to the performance hit as well as not really needing it for anything I use Windows for. Note that games like Valorant have been updated to automatically flag Hyper-V users, but it can work for other titles with a similar anti-cheat. </p></div></div></main>


		<script type="module" data-sveltekit-hydrate="kdj8w7">
		import { start } from "/_app/immutable/start-4a16ffde.js";
		start({
			target: document.querySelector('[data-sveltekit-hydrate="kdj8w7"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [0, 3],
				params: {},
				routeId: "blog/windows-vm-passthrough"
			}
		});
	</script></div>
  </body>
</html>
