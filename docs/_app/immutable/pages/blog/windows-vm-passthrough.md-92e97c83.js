import{S as bo,i as go,s as _o,D as At,x as Io,y as xo,z as Mo,A as Po,B as yo,r as ko,p as Uo,C as Vo,P as wo,e as s,t as f,k as r,c as l,a as h,h as u,d as t,m as n,b as P,U as co,f as it,g as i,M as a,n as Co}from"../../chunks/index-4316d6fd.js";import{P as Eo}from"../../chunks/_post-70c37ccd.js";function Bo(V){let p,c,v,g,m,d,C,ee,te,oe,_,st,k,lt,at,ie,se,le,E,rt,ae,re,ne,y,j,nt,ht,ft,ut,K,pt,mt,yt,dt,q,wt,ct,vt,he,fe,ue,B,bt,pe,me,ye,R,gt,de,we,ce,G,_t,ve,be,ge,I,Q,T,zt,_e,W,It,Ie,xe,Me,H,xt,Pe,ke,Ue,N,Mt,Ve,Ce,Ee,b,F,Pt,kt,J,Ut,Vt,Y,Ct,Be,Re,Ge,L,Et,Te,We,He,A,Bt,Ne,Le,Ae,x,Rt,U,Gt,Tt,ze,Se,Xe,M,Z,z,St,Oe,De,$e,S,Wt,je,Ke,qe,X,Ht,Qe,Fe,Je,O,Nt,Ye,Ze,et,D,Lt;return{c(){p=s("p"),c=f("In early 2021, I transitioned my personal computers to Arch Linux and while the experience has been excellent overall, there are a few shortcomings in the software compatibility department, mainly with a few games (League of Legends) and software I need to use for school (Multisim). While these can be \u201Crun\u201D using wine, I found that the experience left a lot to be desired, and for school especially, I wanted to make sure I was in an environment supported by my classes."),v=r(),g=s("br"),m=r(),d=s("p"),C=f("This led to the decision to use Windows for these as well as anything else not supported well by linux. At this point you might be asking why I\u2019m not just dual-booting for simplicity. The main reasons are that I\u2019ve gotten annoyed with a lot of the telemetry, excess, and clunkiness of running Windows natively on my desktop as well as for the sake of getting some experience with QEMU/KVM on Linux. Note that this won\u2019t be a full guide to the process, but more of a showcase on how I set it up for myself."),ee=r(),te=s("br"),oe=r(),_=s("p"),st=f("Feel free to use anything mentioned here for yourself and be sure to follow along with the files mentioned by viewing them yourself on my "),k=s("a"),lt=f("github"),at=f(". Without further rambling, let\u2019s get into the important parts."),ie=r(),se=s("br"),le=r(),E=s("h2"),rt=f("Hardware & Specifics"),ae=r(),re=s("br"),ne=r(),y=s("p"),j=s("strong"),nt=f("CPU:"),ht=f(" AMD Ryzen 7 3700x "),ft=s("br"),ut=r(),K=s("strong"),pt=f("RAM:"),mt=f(" 16GB DDR4 3600MHz "),yt=s("br"),dt=r(),q=s("strong"),wt=f("GPU:"),ct=f(" EVGA RTX 2080 XC Gaming "),vt=s("br"),he=r(),fe=s("br"),ue=r(),B=s("p"),bt=f("While most hardware choices don\u2019t really matter for this kind of virtualization, eg. get as much memory as you can, have a processor with a lot of threads; one recommendation I can make is to not get an Nvidia GPU. Not only is this good advice for anyone looking to transition to a Linux desktop due to proprietary drivers and other headaches, but it plays a large part in the complexity of this setup as I painfully learned trying to figure out why the VM wouldn\u2019t start when I first set it up, more on this later."),pe=r(),me=s("br"),ye=r(),R=s("p"),gt=f("Other than that, my experience was pretty standard. Setting up a VM through virt-manager and libvirt was the same process as any other type of VM. I installed Windows normally using the default video drivers provided by QEMU and virtio drivers for disks, network, etc, before doing anything GPU related to make sure any errors I had to solve later weren\u2019t related to the VM itself."),de=r(),we=s("br"),ce=r(),G=s("h2"),_t=f("GPU Passthrough"),ve=r(),be=s("br"),ge=r(),I=s("div"),Q=s("p"),T=s("img"),_e=r(),W=s("p"),It=f("Above is my edited vBios file that is passed through to the VM. Usually, when you load into a graphical session, the vBios gets changed as you use the GPU. Because of this, a new vBios is given to the VM to use. Next, to add the GPU alongside any other devices such as a USB controller, I had to get the relevant IOMMU groups. \\ Here\u2019s an example of what the GPU group looked like on my system:"),Ie=r(),xe=s("br"),Me=r(),H=s("p"),xt=f("These were added to the xml file containing all the information for the VM."),Pe=r(),ke=s("br"),Ue=r(),N=s("p"),Mt=f("Now that the normal setup is done, we can move on to specifics in a single GPU setup. The idea is for this process is generally as follows:"),Ve=r(),Ce=s("br"),Ee=r(),b=s("ol"),F=s("li"),Pt=f("Stop the host display server"),kt=r(),J=s("li"),Ut=f("Unload all GPU drivers"),Vt=r(),Y=s("li"),Ct=f("Load the vfio kernel modules in their place"),Be=r(),Re=s("br"),Ge=r(),L=s("p"),Et=f("This is accomplished with scripts that are triggered by the VM starting and stopping. Naturally, start.sh handles startup, with the IOMMU groups sourced from kvm.conf. Lucky for me, you only need to edit the vBios file on Nvidia GPUs. Most documention said this was only required for pascal series (eg. GTX 1070), however, I was unable to get the VM to properly boot without this step. Keep that in mind if you plan on having a similar setup."),Te=r(),We=s("br"),He=r(),A=s("h2"),Bt=f("Optimization"),Ne=r(),Le=s("br"),Ae=r(),x=s("p"),Rt=f("Now that I had a working VM, the next goal was to reduce any latency and overhead from virtualising Windows. Since I planned to play some competitive games that don\u2019t run on linux, it was important to me to make it feel like I was playing on bare metal. The main things I used for this were CPU Pinning and HugePages "),U=s("a"),Gt=f("(Arch Wiki)"),Tt=f(". CPU pinning manually allocates certain threads to the VM so the host doesn\u2019t use them as well, introducing latency. This is configured on a per-CPU basis since every processor has it\u2019s own architechture. In my case, the Ryzen 7 3700x has the following layout:"),ze=r(),Se=s("br"),Xe=r(),M=s("div"),Z=s("p"),z=s("img"),Oe=r(),De=s("br"),$e=r(),S=s("p"),Wt=f("The important sections to look at are the grey boxes which represent a physical core, and the group of grey boxes itself which represents a CCX (Core Complex). I chose to only include cores from one of the two CCX present on the CPU. Since the VM will only be used for gaming and schoolwork, 8 threads should be more than enough performance. Using only one CCX will also improve latency since the cores won\u2019t have to wait on information from the other CCX. Lastly, I chose the second or bottom CCX since I want to leave Core #0 for the host. All of this can be seen in the xml file, specifically in the \u201Ccputune\u201D section."),je=r(),Ke=s("br"),qe=r(),X=s("p"),Ht=f("The last major optimization I included was HugePages. Without going into too much detail, it is an alternate way of providing memory to the VM, which results in a massive difference in performance according to my testing. It is manually allocated using the scripts triggered at startup and deallocated upon closing the VM. I stronly recommend looking into HugePages if you decide to use a setup like this. There were a few other small optimizations that I applied and you might be able to find in the xml file, but they didn\u2019t provide enough of a difference to be meaningful in my opinion."),Qe=r(),Fe=s("br"),Je=r(),O=s("h2"),Nt=f("Hyper-V"),Ye=r(),Ze=s("br"),et=r(),D=s("p"),Lt=f("Hyper-V is a virtualization platform on Windows, and it\u2019s normally used in this case to hide the nature of the host to the guest machine. In other words, you can use it to hide the fact that you are using a VM to circumvent some anti-cheats and other software restrictions. I chose not to use it in my setup due to the performance hit as well as not really needing it for anything I use Windows for. Note that games like Valorant have been updated to automatically flag Hyper-V users, but it can work for other titles with a similar anti-cheat."),this.h()},l(e){p=l(e,"P",{});var o=h(p);c=u(o,"In early 2021, I transitioned my personal computers to Arch Linux and while the experience has been excellent overall, there are a few shortcomings in the software compatibility department, mainly with a few games (League of Legends) and software I need to use for school (Multisim). While these can be \u201Crun\u201D using wine, I found that the experience left a lot to be desired, and for school especially, I wanted to make sure I was in an environment supported by my classes."),o.forEach(t),v=n(e),g=l(e,"BR",{}),m=n(e),d=l(e,"P",{});var Xt=h(d);C=u(Xt,"This led to the decision to use Windows for these as well as anything else not supported well by linux. At this point you might be asking why I\u2019m not just dual-booting for simplicity. The main reasons are that I\u2019ve gotten annoyed with a lot of the telemetry, excess, and clunkiness of running Windows natively on my desktop as well as for the sake of getting some experience with QEMU/KVM on Linux. Note that this won\u2019t be a full guide to the process, but more of a showcase on how I set it up for myself."),Xt.forEach(t),ee=n(e),te=l(e,"BR",{}),oe=n(e),_=l(e,"P",{});var tt=h(_);st=u(tt,"Feel free to use anything mentioned here for yourself and be sure to follow along with the files mentioned by viewing them yourself on my "),k=l(tt,"A",{href:!0,rel:!0});var Ot=h(k);lt=u(Ot,"github"),Ot.forEach(t),at=u(tt,". Without further rambling, let\u2019s get into the important parts."),tt.forEach(t),ie=n(e),se=l(e,"BR",{}),le=n(e),E=l(e,"H2",{});var Dt=h(E);rt=u(Dt,"Hardware & Specifics"),Dt.forEach(t),ae=n(e),re=l(e,"BR",{}),ne=n(e),y=l(e,"P",{});var w=h(y);j=l(w,"STRONG",{});var $t=h(j);nt=u($t,"CPU:"),$t.forEach(t),ht=u(w," AMD Ryzen 7 3700x "),ft=l(w,"BR",{}),ut=n(w),K=l(w,"STRONG",{});var jt=h(K);pt=u(jt,"RAM:"),jt.forEach(t),mt=u(w," 16GB DDR4 3600MHz "),yt=l(w,"BR",{}),dt=n(w),q=l(w,"STRONG",{});var Kt=h(q);wt=u(Kt,"GPU:"),Kt.forEach(t),ct=u(w," EVGA RTX 2080 XC Gaming "),vt=l(w,"BR",{}),w.forEach(t),he=n(e),fe=l(e,"BR",{}),ue=n(e),B=l(e,"P",{});var qt=h(B);bt=u(qt,"While most hardware choices don\u2019t really matter for this kind of virtualization, eg. get as much memory as you can, have a processor with a lot of threads; one recommendation I can make is to not get an Nvidia GPU. Not only is this good advice for anyone looking to transition to a Linux desktop due to proprietary drivers and other headaches, but it plays a large part in the complexity of this setup as I painfully learned trying to figure out why the VM wouldn\u2019t start when I first set it up, more on this later."),qt.forEach(t),pe=n(e),me=l(e,"BR",{}),ye=n(e),R=l(e,"P",{});var Qt=h(R);gt=u(Qt,"Other than that, my experience was pretty standard. Setting up a VM through virt-manager and libvirt was the same process as any other type of VM. I installed Windows normally using the default video drivers provided by QEMU and virtio drivers for disks, network, etc, before doing anything GPU related to make sure any errors I had to solve later weren\u2019t related to the VM itself."),Qt.forEach(t),de=n(e),we=l(e,"BR",{}),ce=n(e),G=l(e,"H2",{});var Ft=h(G);_t=u(Ft,"GPU Passthrough"),Ft.forEach(t),ve=n(e),be=l(e,"BR",{}),ge=n(e),I=l(e,"DIV",{style:!0});var Jt=h(I);Q=l(Jt,"P",{});var Yt=h(Q);T=l(Yt,"IMG",{src:!0,alt:!0}),Yt.forEach(t),Jt.forEach(t),_e=n(e),W=l(e,"P",{});var Zt=h(W);It=u(Zt,"Above is my edited vBios file that is passed through to the VM. Usually, when you load into a graphical session, the vBios gets changed as you use the GPU. Because of this, a new vBios is given to the VM to use. Next, to add the GPU alongside any other devices such as a USB controller, I had to get the relevant IOMMU groups. \\ Here\u2019s an example of what the GPU group looked like on my system:"),Zt.forEach(t),Ie=n(e),xe=l(e,"BR",{}),Me=n(e),H=l(e,"P",{});var eo=h(H);xt=u(eo,"These were added to the xml file containing all the information for the VM."),eo.forEach(t),Pe=n(e),ke=l(e,"BR",{}),Ue=n(e),N=l(e,"P",{});var to=h(N);Mt=u(to,"Now that the normal setup is done, we can move on to specifics in a single GPU setup. The idea is for this process is generally as follows:"),to.forEach(t),Ve=n(e),Ce=l(e,"BR",{}),Ee=n(e),b=l(e,"OL",{});var $=h(b);F=l($,"LI",{});var oo=h(F);Pt=u(oo,"Stop the host display server"),oo.forEach(t),kt=n($),J=l($,"LI",{});var io=h(J);Ut=u(io,"Unload all GPU drivers"),io.forEach(t),Vt=n($),Y=l($,"LI",{});var so=h(Y);Ct=u(so,"Load the vfio kernel modules in their place"),so.forEach(t),$.forEach(t),Be=n(e),Re=l(e,"BR",{}),Ge=n(e),L=l(e,"P",{});var lo=h(L);Et=u(lo,"This is accomplished with scripts that are triggered by the VM starting and stopping. Naturally, start.sh handles startup, with the IOMMU groups sourced from kvm.conf. Lucky for me, you only need to edit the vBios file on Nvidia GPUs. Most documention said this was only required for pascal series (eg. GTX 1070), however, I was unable to get the VM to properly boot without this step. Keep that in mind if you plan on having a similar setup."),lo.forEach(t),Te=n(e),We=l(e,"BR",{}),He=n(e),A=l(e,"H2",{});var ao=h(A);Bt=u(ao,"Optimization"),ao.forEach(t),Ne=n(e),Le=l(e,"BR",{}),Ae=n(e),x=l(e,"P",{});var ot=h(x);Rt=u(ot,"Now that I had a working VM, the next goal was to reduce any latency and overhead from virtualising Windows. Since I planned to play some competitive games that don\u2019t run on linux, it was important to me to make it feel like I was playing on bare metal. The main things I used for this were CPU Pinning and HugePages "),U=l(ot,"A",{href:!0,rel:!0});var ro=h(U);Gt=u(ro,"(Arch Wiki)"),ro.forEach(t),Tt=u(ot,". CPU pinning manually allocates certain threads to the VM so the host doesn\u2019t use them as well, introducing latency. This is configured on a per-CPU basis since every processor has it\u2019s own architechture. In my case, the Ryzen 7 3700x has the following layout:"),ot.forEach(t),ze=n(e),Se=l(e,"BR",{}),Xe=n(e),M=l(e,"DIV",{style:!0});var no=h(M);Z=l(no,"P",{});var ho=h(Z);z=l(ho,"IMG",{src:!0,alt:!0}),ho.forEach(t),no.forEach(t),Oe=n(e),De=l(e,"BR",{}),$e=n(e),S=l(e,"P",{});var fo=h(S);Wt=u(fo,"The important sections to look at are the grey boxes which represent a physical core, and the group of grey boxes itself which represents a CCX (Core Complex). I chose to only include cores from one of the two CCX present on the CPU. Since the VM will only be used for gaming and schoolwork, 8 threads should be more than enough performance. Using only one CCX will also improve latency since the cores won\u2019t have to wait on information from the other CCX. Lastly, I chose the second or bottom CCX since I want to leave Core #0 for the host. All of this can be seen in the xml file, specifically in the \u201Ccputune\u201D section."),fo.forEach(t),je=n(e),Ke=l(e,"BR",{}),qe=n(e),X=l(e,"P",{});var uo=h(X);Ht=u(uo,"The last major optimization I included was HugePages. Without going into too much detail, it is an alternate way of providing memory to the VM, which results in a massive difference in performance according to my testing. It is manually allocated using the scripts triggered at startup and deallocated upon closing the VM. I stronly recommend looking into HugePages if you decide to use a setup like this. There were a few other small optimizations that I applied and you might be able to find in the xml file, but they didn\u2019t provide enough of a difference to be meaningful in my opinion."),uo.forEach(t),Qe=n(e),Fe=l(e,"BR",{}),Je=n(e),O=l(e,"H2",{});var po=h(O);Nt=u(po,"Hyper-V"),po.forEach(t),Ye=n(e),Ze=l(e,"BR",{}),et=n(e),D=l(e,"P",{});var mo=h(D);Lt=u(mo,"Hyper-V is a virtualization platform on Windows, and it\u2019s normally used in this case to hide the nature of the host to the guest machine. In other words, you can use it to hide the fact that you are using a VM to circumvent some anti-cheats and other software restrictions. I chose not to use it in my setup due to the performance hit as well as not really needing it for anything I use Windows for. Note that games like Valorant have been updated to automatically flag Hyper-V users, but it can work for other titles with a similar anti-cheat."),mo.forEach(t),this.h()},h(){P(k,"href","https://github.com/kleidibujari/virt-machine"),P(k,"rel","nofollow"),co(T.src,zt="/blog/windows-vm-passthrough/gpu-hex.png")||P(T,"src",zt),P(T,"alt","vbios hex dump"),it(I,"display","flex"),it(I,"justify-content","center"),P(U,"href","https://wiki.archlinux.org/title/KVM#Enabling_huge_pages"),P(U,"rel","nofollow"),co(z.src,St="/blog/windows-vm-passthrough/lstopo.png")||P(z,"src",St),P(z,"alt","vbios hex dump"),it(M,"display","flex"),it(M,"justify-content","center")},m(e,o){i(e,p,o),a(p,c),i(e,v,o),i(e,g,o),i(e,m,o),i(e,d,o),a(d,C),i(e,ee,o),i(e,te,o),i(e,oe,o),i(e,_,o),a(_,st),a(_,k),a(k,lt),a(_,at),i(e,ie,o),i(e,se,o),i(e,le,o),i(e,E,o),a(E,rt),i(e,ae,o),i(e,re,o),i(e,ne,o),i(e,y,o),a(y,j),a(j,nt),a(y,ht),a(y,ft),a(y,ut),a(y,K),a(K,pt),a(y,mt),a(y,yt),a(y,dt),a(y,q),a(q,wt),a(y,ct),a(y,vt),i(e,he,o),i(e,fe,o),i(e,ue,o),i(e,B,o),a(B,bt),i(e,pe,o),i(e,me,o),i(e,ye,o),i(e,R,o),a(R,gt),i(e,de,o),i(e,we,o),i(e,ce,o),i(e,G,o),a(G,_t),i(e,ve,o),i(e,be,o),i(e,ge,o),i(e,I,o),a(I,Q),a(Q,T),i(e,_e,o),i(e,W,o),a(W,It),i(e,Ie,o),i(e,xe,o),i(e,Me,o),i(e,H,o),a(H,xt),i(e,Pe,o),i(e,ke,o),i(e,Ue,o),i(e,N,o),a(N,Mt),i(e,Ve,o),i(e,Ce,o),i(e,Ee,o),i(e,b,o),a(b,F),a(F,Pt),a(b,kt),a(b,J),a(J,Ut),a(b,Vt),a(b,Y),a(Y,Ct),i(e,Be,o),i(e,Re,o),i(e,Ge,o),i(e,L,o),a(L,Et),i(e,Te,o),i(e,We,o),i(e,He,o),i(e,A,o),a(A,Bt),i(e,Ne,o),i(e,Le,o),i(e,Ae,o),i(e,x,o),a(x,Rt),a(x,U),a(U,Gt),a(x,Tt),i(e,ze,o),i(e,Se,o),i(e,Xe,o),i(e,M,o),a(M,Z),a(Z,z),i(e,Oe,o),i(e,De,o),i(e,$e,o),i(e,S,o),a(S,Wt),i(e,je,o),i(e,Ke,o),i(e,qe,o),i(e,X,o),a(X,Ht),i(e,Qe,o),i(e,Fe,o),i(e,Je,o),i(e,O,o),a(O,Nt),i(e,Ye,o),i(e,Ze,o),i(e,et,o),i(e,D,o),a(D,Lt)},p:Co,d(e){e&&t(p),e&&t(v),e&&t(g),e&&t(m),e&&t(d),e&&t(ee),e&&t(te),e&&t(oe),e&&t(_),e&&t(ie),e&&t(se),e&&t(le),e&&t(E),e&&t(ae),e&&t(re),e&&t(ne),e&&t(y),e&&t(he),e&&t(fe),e&&t(ue),e&&t(B),e&&t(pe),e&&t(me),e&&t(ye),e&&t(R),e&&t(de),e&&t(we),e&&t(ce),e&&t(G),e&&t(ve),e&&t(be),e&&t(ge),e&&t(I),e&&t(_e),e&&t(W),e&&t(Ie),e&&t(xe),e&&t(Me),e&&t(H),e&&t(Pe),e&&t(ke),e&&t(Ue),e&&t(N),e&&t(Ve),e&&t(Ce),e&&t(Ee),e&&t(b),e&&t(Be),e&&t(Re),e&&t(Ge),e&&t(L),e&&t(Te),e&&t(We),e&&t(He),e&&t(A),e&&t(Ne),e&&t(Le),e&&t(Ae),e&&t(x),e&&t(ze),e&&t(Se),e&&t(Xe),e&&t(M),e&&t(Oe),e&&t(De),e&&t($e),e&&t(S),e&&t(je),e&&t(Ke),e&&t(qe),e&&t(X),e&&t(Qe),e&&t(Fe),e&&t(Je),e&&t(O),e&&t(Ye),e&&t(Ze),e&&t(et),e&&t(D)}}}function Ro(V){let p,c;const v=[V[0],vo];let g={$$slots:{default:[Bo]},$$scope:{ctx:V}};for(let m=0;m<v.length;m+=1)g=At(g,v[m]);return p=new Eo({props:g}),{c(){Io(p.$$.fragment)},l(m){xo(p.$$.fragment,m)},m(m,d){Mo(p,m,d),c=!0},p(m,[d]){const C=d&1?Po(v,[d&1&&yo(m[0]),d&0&&yo(vo)]):{};d&2&&(C.$$scope={dirty:d,ctx:m}),p.$set(C)},i(m){c||(ko(p.$$.fragment,m),c=!0)},o(m){Uo(p.$$.fragment,m),c=!1},d(m){Vo(p,m)}}}const vo={title:"Making a High performance Win10 VM with GPU-Passthrough",date:"2022-01-15",length:"Medium"};function Go(V,p,c){return V.$$set=v=>{c(0,p=At(At({},p),wo(v)))},p=wo(p),[p]}class Ho extends bo{constructor(p){super(),go(this,p,Go,Ro,_o,{})}}export{Ho as default,vo as metadata};
